# Commands

## Questions

- What about git bisect?

## Project initialization

- Setting up environment

```bash
git init # create .git folder
git clone <url> # copes existing repo from server to machine
git config --global user.name "Your name"
```

## Staging & Commiting

```bash
git status # shows which files are modified

# Adding file(s)
git add <file>
git add .
git add -p # iterates through changes and allows you to select which one you want to use
git commit -m "msg"
git commit --amend -m # fixes last message
```

## Branching & context switching

```bash
git branch # all local branches list [simplified]
git branch -v # branches list => branch name + last hash + last commit messages [informative]
git branch -vv # similar to -v, however, shows remote link  [more complete]
git checkout <name> # checkout to existing branch
git checkout -b <name> # create a new branch
git switch - # handy shortcut to jump back to previous branch you were on
git branch -d <name> # deleting a branch
git branch -m <new-name> # rename current branch
git branch -m <old-name> <new-name> # rename other branches
```

## Integrating changes | merging & rebasing

```bash
git merge <branch> # brings <branch> into current
git merge --no-ff <branch> # forces a merge even if a fast-forward is possible [preserves history]
git merge --squash <branch> # takes all changes from <branch> and puts them into a single commit
git merge --abort

git rebase <branch> # moves your current's branch commits to the tip of <branch>
git rebase -i <hash/ref> # interactive: opens a list to squash, edit, or drop commits
git rebase --continue # resumes it after conflict
git rebase --abort

git cherry-pick <hash> # grabs a specific commit + merge it
git cherry-pick -n <hash> # grabs a specific commit + doesn't merge it
```

### Git cherry-pick

- Copy-paste for commits
- Differently from `merge` and `rebase`, which move entire branches, `cherry-pick` allows us to grab specific commits and apply them to current branch

```bash
git checkout <destination-branch>
git cherry-pick <hash> # grab one specific commit from another branch
git cherry-pick -n <hash> # -n (no commit) | grab it, but don't commit, keep it in staging
git cherry-pick <hash1> <hash2> # grab multiple commits at once
git cherry-pick <hash1>..<hash-n> # grab a range of commits
git cherry-pick --continue # to continue after a conflict
git cherry-pick --abort
```

## Working with remote repos

### connection and inspection

```bash
git remote -v # shows where you local code is connected to
git branch -a # lists all branches + include remote
git branch -vv # checking local/remote link | -vv: very verbose
git remote show origin # high-level status report of the local machine and specific remote
git diff <local> origin/<remote> # compares local branch with remote
```

### sync | bringing changes in

```bash
git fetch # checks the server for updates, but doesn't touch the code. Safe to run anytime
git pull # fetches + merge
git pull --rebase ## fetches + rebase
git fetch --prune # clean up, removing ghost references
```

### branching and tracking

```bash
git checkout -b <branch-name> origin/<branch-name> # old | create new local branch + tracks remote
git checkout <branch-name> # if no find local, grabs + tracks remote
git switch <branch-name> # same as above
```

### sharing | sending changes out

```bash
git push -u origin <branch> # send local snapshots to server
git push origin --delete <branch-name> # deleting a remote branch
```

### git branch -vv

It shows:

```bash
  b-1  53a791a [origin/b-1] rename files
* main 108b41c [origin/main] notes git branches ii

# * current branch
# <branch-name> <short-hash-last-commit> <[link]> <last-commit-message>
# link: which remote branch local one is tracking
```

### `git pull --rebase`

- Cleaner way to stay up to date
  - by default `git pull` does a merge

How does `git pull --rebase` work?

1. Lifts your local commits that aren't on the server yet
2. Downloads the new commits from the server (the base)
3. Replays your local commits, one by one, on top of the new base

| strategy          | command            | best for                                             |
| ----------------- | ------------------ | ---------------------------------------------------- |
| default (merge)   | git pull           | preserving chronological truth                       |
| rebase            | git pull --rebase  | keeping a clean, linear project history              |
| fast-forward only | git pull --ff-only | Ensure never to accidentally create a merge conflict |

## Inspection and comparison

```bash
git log --oneline --graph --all # shows visual tree of history
git diff  <branch-1>..<branch-2> # compare two branches
git diff <branch-1>..<branch-2> --stat # lists changes files + lines
git diff # shows what changed, but haven't been staged yet
git diff --staged # what you staged, but haven't commited
git blame <file> # shows line-by-line who last edited a file and why
```

## Temporary storage & snipping (power tools)

```bash
git stash # hits 'pause'. Hides uncommited work so you can switch branches
git stash pop # hits 'play'. Brings back hidden work
git cherry-pick <hash> # snipes a single commit from another branch and applies to your current one
git rebase -i HEAD~n # squash tool. Rewrites the last `n` commits to clean them up
```

## Emergency kit (undo commands)

```bash
git restore --staged <file> # unstages a file
git restore <file> # restore the file
git reset --soft HEAD~n # undoes `n` commits + keeps the code
git reset --hard HEAD~n # undoes `n` commits + DOESN'T keep the code! (danger)

git rm -r <folder-name> # remove the folder recursively

# this merge/rebase is a mess!
git merge --abort
git rebase --abort
```
